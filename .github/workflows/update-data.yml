name: æ›´æ–°å°ˆæ¡ˆé€²åº¦è³‡æ–™

on:
  schedule:
    # æ¯ 2 å°æ™‚åŸ·è¡Œä¸€æ¬¡
    - cron: '0 */2 * * *'
  workflow_dispatch: # å…è¨±æ‰‹å‹•è§¸ç™¼
  push:
    branches: [ main ]
    paths:
      - 'js/config.js' # ç•¶é…ç½®æª”æ¡ˆè®Šæ›´æ™‚ä¹Ÿè§¸ç™¼

permissions:
  contents: write
  issues: read

jobs:
  update-progress-data:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.PAT || secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install dependencies
      run: |
        npm init -y
        npm install axios

    - name: Create data collection script
      run: |
        cat > collect-data.js << 'EOF'
        const fs = require('fs');
        const axios = require('axios');

        // é…ç½®
        const repositories = [
          {
            name: "Er å°ˆæ¡ˆç¾¤",
            owner: "mingxianliu",
            repoPattern: "Er*",
            description: "è‡ªå‹•åŒ¹é…æ‰€æœ‰ä»¥ Er é–‹é ­çš„ repo",
            color: "#17a2b8",
            priority: 1,
            prefixRules: [
              { pattern: "ErCore*",    prefix: "ERC" },
              { pattern: "ErAI*",      prefix: "ERA" },
              { pattern: "ErAid-Ecosystem*", prefix: "ERAI" },
              { pattern: "ErForge*",   prefix: "ERF" },
              { pattern: "ErTidy*",    prefix: "ERT" },
              { pattern: "ErGrant*",   prefix: "ERG" },
              { pattern: "ErStore*",   prefix: "ERS" },
              { pattern: "ErSlice*",   prefix: "ERSL" },
              { pattern: "ErShield*",  prefix: "ERSH" },
              { pattern: "ErShowcase*",prefix: "ERSC" },
              { pattern: "ErProphet*", prefix: "ERP" },
              { pattern: "*",          prefix: "ER" }
            ],
            colorRules: [
              { pattern: "ErCore*",    color: "#ff6b6b" },
              { pattern: "ErAI*",      color: "#845ef7" },
              { pattern: "ErAid-Ecosystem*", color: "#fd7e14" },
              { pattern: "ErForge*",   color: "#6f42c1" },
              { pattern: "ErTidy*",    color: "#20c997" },
              { pattern: "ErGrant*",   color: "#e83e8c" },
              { pattern: "ErStore*",   color: "#007bff" },
              { pattern: "ErSlice*",   color: "#dc3545" },
              { pattern: "ErShield*",  color: "#343a40" },
              { pattern: "ErShowcase*",color: "#ffc107" },
              { pattern: "ErProphet*", color: "#6610f2" },
              { pattern: "*",          color: "#17a2b8" }
            ]
          }
        ];

        class GitHubAPI {
          constructor(token) {
            this.token = token;
            this.baseUrl = 'https://api.github.com';
            this.headers = {
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'Project-Dashboard'
            };
            if (this.token) {
              this.headers['Authorization'] = \`token \${this.token}\`;
            }
          }

          async sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
          }

          async fetchWithRetry(apiCall, retries = 3) {
            for (let i = 0; i < retries; i++) {
              try {
                return await apiCall();
              } catch (error) {
                console.log(\`API å‘¼å«å¤±æ•—ï¼Œé‡è©¦ \${i + 1}/\${retries}: \${error.message}\`);
                if (i < retries - 1) {
                  await this.sleep(1000 * (i + 1)); // éå¢å»¶é²
                } else {
                  throw error;
                }
              }
            }
          }

          async getRepository(owner, repo) {
            return await this.fetchWithRetry(async () => {
              const response = await axios.get(\`\${this.baseUrl}/repos/\${owner}/\${repo}\`, {
                headers: this.headers
              });
              return response.data;
            });
          }

          async getAllIssues(owner, repo) {
            let allIssues = [];
            let page = 1;
            const perPage = 100;
            let hasMorePages = true;

            while (hasMorePages) {
              try {
                const response = await this.fetchWithRetry(async () => {
                  return await axios.get(\`\${this.baseUrl}/repos/\${owner}/\${repo}/issues\`, {
                    headers: this.headers,
                    params: {
                      state: 'all',
                      per_page: perPage,
                      page: page
                    }
                  });
                });

                if (response.data.length === 0) {
                  hasMorePages = false;
                } else {
                  allIssues = allIssues.concat(response.data);
                  page++;
                  // é¿å…éæ–¼é »ç¹çš„ API å‘¼å«
                  await this.sleep(100);
                }
              } catch (error) {
                console.error(\`å–å¾— \${owner}/\${repo} issues ç¬¬ \${page} é æ™‚ç™¼ç”ŸéŒ¯èª¤:\`, error.message);
                // å¦‚æœæ˜¯æ¬Šé™å•é¡Œæˆ– repository ä¸å­˜åœ¨ï¼Œç›´æ¥è¿”å›å·²æ”¶é›†çš„è³‡æ–™
                if (error.response && (error.response.status === 403 || error.response.status === 404)) {
                  console.log(\`è·³é \${owner}/\${repo}ï¼Œå¯èƒ½æ˜¯æ¬Šé™å•é¡Œæˆ– repository ä¸å­˜åœ¨\`);
                  break;
                }
                // å…¶ä»–éŒ¯èª¤ä¹Ÿè·³éï¼Œä½†è¨˜éŒ„ä¸‹ä¾†
                hasMorePages = false;
              }
            }

            console.log(\`å¾ \${owner}/\${repo} æ”¶é›†åˆ° \${allIssues.length} å€‹ issues\`);
            return allIssues;
          }

          async listOwnerReposAll(owner) {
            let allRepos = [];
            let page = 1;
            const perPage = 100;
            let hasMorePages = true;

            while (hasMorePages) {
              try {
                const response = await this.fetchWithRetry(async () => {
                  return await axios.get(\`\${this.baseUrl}/users/\${owner}/repos\`, {
                    headers: this.headers,
                    params: {
                      per_page: perPage,
                      page: page,
                      sort: 'updated',
                      direction: 'desc'
                    }
                  });
                });

                if (response.data.length === 0) {
                  hasMorePages = false;
                } else {
                  allRepos = allRepos.concat(response.data);
                  page++;
                  // é¿å…éæ–¼é »ç¹çš„ API å‘¼å«
                  await this.sleep(100);
                }
              } catch (error) {
                console.error(\`å–å¾— \${owner} çš„ repositories ç¬¬ \${page} é æ™‚ç™¼ç”ŸéŒ¯èª¤:\`, error.message);
                // å¦‚æœæ˜¯æ¬Šé™å•é¡Œï¼Œç›´æ¥è¿”å›å·²æ”¶é›†çš„è³‡æ–™
                if (error.response && (error.response.status === 403 || error.response.status === 404)) {
                  console.log(\`è·³é \${owner}ï¼Œå¯èƒ½æ˜¯æ¬Šé™å•é¡Œæˆ–ä½¿ç”¨è€…ä¸å­˜åœ¨\`);
                  break;
                }
                hasMorePages = false;
              }
            }

            console.log(\`å¾ \${owner} æ”¶é›†åˆ° \${allRepos.length} å€‹ repositories\`);
            return allRepos;
          }

          filterReposByPattern(repos, pattern) {
            const regex = new RegExp(pattern.replace(/\\*/g, '.*'), 'i');
            return repos.filter(repo => regex.test(repo.name));
          }

          getPrefixForRepo(repoName, prefixRules) {
            for (const rule of prefixRules) {
              const regex = new RegExp(rule.pattern.replace(/\\*/g, '.*'), 'i');
              if (regex.test(repoName)) {
                return rule.prefix;
              }
            }
            return 'ER';
          }

          getColorForRepo(repoName, colorRules) {
            for (const rule of colorRules) {
              const regex = new RegExp(rule.pattern.replace(/\\*/g, '.*'), 'i');
              if (regex.test(repoName)) {
                return rule.color;
              }
            }
            return '#17a2b8';
          }

          analyzeFeatureProgress(issues, featurePrefix) {
            const features = [];
            const prefixPattern = new RegExp(\`\\\\[\${featurePrefix}\\\\d{4}\\\\]\`, 'i');

            issues.forEach(issue => {
              if (prefixPattern.test(issue.title)) {
                const match = issue.title.match(new RegExp(\`\\\\[(\${featurePrefix}\\\\d{4})\\\\]\`, 'i'));
                if (match) {
                  const featureCode = match[1];
                  features.push({
                    code: featureCode,
                    title: issue.title.replace(new RegExp(\`\\\\[\${featurePrefix}\\\\d{4}\\\\]\`, 'gi'), '').trim(),
                    status: issue.state,
                    url: issue.html_url,
                    created: issue.created_at,
                    updated: issue.updated_at,
                    assignee: issue.assignee ? issue.assignee.login : null
                  });
                }
              }
            });

            return features;
          }

          calculateProjectStats(features) {
            const total = features.length;
            const completed = features.filter(f => f.status === 'closed').length;
            const inProgress = features.filter(f => f.status === 'open').length;
            const progress = total > 0 ? Math.round((completed / total) * 100) : 0;

            return {
              total,
              completed,
              inProgress,
              progress
            };
          }
        }

        async function collectData() {
          const token = process.env.GITHUB_TOKEN || process.env.PAT;
          const github = new GitHubAPI(token);

          const data = {
            lastUpdate: new Date().toISOString(),
            projects: [],
            recentActivity: []
          };

          let successCount = 0;
          let errorCount = 0;

          for (const repoConfig of repositories) {
            try {
              if (repoConfig.repoPattern) {
                console.log(\`è™•ç† \${repoConfig.owner} çš„ \${repoConfig.repoPattern} æ¨¡å¼...\`);
                
                const allRepos = await github.listOwnerReposAll(repoConfig.owner);
                const matchedRepos = github.filterReposByPattern(allRepos, repoConfig.repoPattern);
                
                console.log(\`æ‰¾åˆ° \${matchedRepos.length} å€‹åŒ¹é…çš„ repositories\`);

                for (const repo of matchedRepos) {
                  try {
                    console.log(\`è™•ç† \${repoConfig.owner}/\${repo.name}...\`);
                    
                    const issues = await github.getAllIssues(repoConfig.owner, repo.name);
                    
                    const featurePrefix = github.getPrefixForRepo(repo.name, repoConfig.prefixRules);
                    const color = github.getColorForRepo(repo.name, repoConfig.colorRules);
                    
                    const features = github.analyzeFeatureProgress(issues, featurePrefix);
                    const stats = github.calculateProjectStats(features);

                    data.projects.push({
                      name: repo.name,
                      owner: repoConfig.owner,
                      repo: repo.name,
                      description: repo.description || '',
                      url: repo.html_url,
                      color: color,
                      stats: stats,
                      features: features.slice(0, 10)
                    });

                    issues.slice(0, 5).forEach(issue => {
                      data.recentActivity.push({
                        project: repo.name,
                        title: issue.title,
                        action: issue.state === 'closed' ? 'å®Œæˆ' : 'æ›´æ–°',
                        url: issue.html_url,
                        updated: issue.updated_at,
                        assignee: issue.assignee ? issue.assignee.login : null
                      });
                    });

                    successCount++;
                    console.log(\`âœ… æˆåŠŸè™•ç† \${repoConfig.owner}/\${repo.name}\`);

                  } catch (error) {
                    errorCount++;
                    console.error(\`âŒ è™•ç† \${repoConfig.owner}/\${repo.name} æ™‚ç™¼ç”ŸéŒ¯èª¤:\`, error.message);
                    // ç¹¼çºŒè™•ç†ä¸‹ä¸€å€‹ repository
                    continue;
                  }
                }
              }
            } catch (error) {
              errorCount++;
              console.error(\`âŒ è™•ç† \${repoConfig.owner} æ™‚ç™¼ç”ŸéŒ¯èª¤:\`, error.message);
              // ç¹¼çºŒè™•ç†ä¸‹ä¸€å€‹é…ç½®
              continue;
            }
          }

          data.recentActivity.sort((a, b) => new Date(b.updated) - new Date(a.updated));
          data.recentActivity = data.recentActivity.slice(0, 20);

          console.log(\`ğŸ“Š è³‡æ–™æ”¶é›†å®Œæˆ: æˆåŠŸ \${successCount} å€‹ï¼Œå¤±æ•— \${errorCount} å€‹\`);
          return data;
        }

        collectData().then(data => {
          console.log(\`æ”¶é›†åˆ° \${data.projects.length} å€‹å°ˆæ¡ˆ\`);
          console.log(\`æ”¶é›†åˆ° \${data.recentActivity.length} å€‹æ´»å‹•è¨˜éŒ„\`);
          
          if (!fs.existsSync('./data')) {
            fs.mkdirSync('./data', { recursive: true });
          }
          
          fs.writeFileSync('./data/progress.json', JSON.stringify(data, null, 2));
          console.log('âœ… è³‡æ–™æ”¶é›†å®Œæˆï¼Œå·²å¯«å…¥ data/progress.json');
          
          // å³ä½¿éƒ¨åˆ†å¤±æ•—ï¼Œä¹Ÿå¯«å…¥éƒ¨åˆ†è³‡æ–™
          if (data.projects.length === 0) {
            console.log('âš ï¸ è­¦å‘Š: æ²’æœ‰æ”¶é›†åˆ°ä»»ä½•å°ˆæ¡ˆè³‡æ–™');
          }
        }).catch(error => {
          console.error('âŒ è³‡æ–™æ”¶é›†å¤±æ•—:', error);
          console.error('éŒ¯èª¤å †ç–Š:', error.stack);
          
          // å¯«å…¥ç©ºçš„è³‡æ–™æª”æ¡ˆï¼Œé¿å…å®Œå…¨å¤±æ•—
          const emptyData = {
            lastUpdate: new Date().toISOString(),
            projects: [],
            recentActivity: [],
            error: error.message
          };
          
          if (!fs.existsSync('./data')) {
            fs.mkdirSync('./data', { recursive: true });
          }
          
          fs.writeFileSync('./data/progress.json', JSON.stringify(emptyData, null, 2));
          console.log('âš ï¸ å·²å¯«å…¥ç©ºçš„è³‡æ–™æª”æ¡ˆ');
          
          // ä¸è¦é€€å‡ºï¼Œè®“å·¥ä½œæµç¨‹ç¹¼çºŒ
        });
        EOF

    - name: Collect project data
      env:
        GITHUB_TOKEN: ${{ secrets.PAT || secrets.GITHUB_TOKEN }}
      run: |
        echo "é–‹å§‹æ”¶é›†å°ˆæ¡ˆè³‡æ–™..."
        node collect-data.js
        echo "è³‡æ–™æ”¶é›†å®Œæˆ"

    - name: Commit and push changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add data/progress.json
        if git diff --staged --quiet; then
          echo "æ²’æœ‰è®Šæ›´éœ€è¦æäº¤"
        else
          git commit -m "è‡ªå‹•æ›´æ–°å°ˆæ¡ˆé€²åº¦è³‡æ–™ [skip ci]"
          git push
          echo "å·²æäº¤ä¸¦æ¨é€æ›´æ–°"
        fi

    - name: Verify update
      run: |
        if [ -f "data/progress.json" ]; then
          echo "âœ… progress.json æª”æ¡ˆå­˜åœ¨"
          echo "æª”æ¡ˆå¤§å°: $(wc -c < data/progress.json) bytes"
          echo "æœ€å¾Œæ›´æ–°æ™‚é–“: $(jq -r '.lastUpdate' data/progress.json)"
        else
          echo "âŒ progress.json æª”æ¡ˆä¸å­˜åœ¨"
          exit 1
        fi